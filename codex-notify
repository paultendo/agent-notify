#!/usr/bin/env bash
set -euo pipefail

VERSION="0.6.0"

case "${1:-}" in
  --version|-v|-V)
    echo "codex-notify $VERSION"
    exit 0
    ;;
  --help|-h)
    cat <<'HELP'
codex-notify - macOS notifications for OpenAI Codex

Usage:
  codex-notify <json-payload>        Codex notify hook mode
  codex-notify "Title" "Message"     Manual notification
  codex-notify --test                Fire a test completion notification
  codex-notify --test-approval       Fire a test approval notification
  codex-notify --test-say            Fire a test notification with TTS
  codex-notify --setup               Add notify hook to ~/.codex/config.toml
  codex-notify --update              Update to the latest release
  codex-notify --version             Print version
  codex-notify --help                Show this help

Environment variables:
  CODEX_NOTIFY_SOUND           Completion sound (default: Glass)
  CODEX_NOTIFY_APPROVAL_SOUND  Approval/input-needed sound (default: Sosumi)
  CODEX_SILENT=1               Disable sound
  CODEX_NOTIFY_QUIET=1         Suppress terminal echo line
  CODEX_ACTIVATE_BUNDLE        App to activate on click (default: com.microsoft.VSCode)
  CODEX_SENDER_BUNDLE          Sender bundle for -activate mode icon
  CODEX_SUPPRESS_FRONTMOST     Set to 0 to always notify
  CODEX_NOTIFY_EVENT_TYPES     Event types to handle, comma-separated (default: *)
  CODEX_NOTIFY_EXEC_ONLY       Set to 0 for -activate instead of -execute
  CODEX_NOTIFY_APP_ICON        Custom icon path or URL
  CODEX_NOTIFY_SAY=1           Speak notification via macOS say
  CODEX_NOTIFY_SAY_VOICE       Voice for say (e.g. Daniel)
  CODEX_NOTIFY_SAY_RATE        Speech rate for say (words per minute)
  CODEX_NOTIFY_WEBHOOK         Webhook URL (Discord, Slack, etc.)
  CODEX_NOTIFY_EXEC_CMD        Override the click-execute command
  CODEX_NOTIFY_DND=1           Skip notification when Focus/DND is active
  CODEX_NOTIFY_SCHEDULE        Notify only during HH:MM-HH:MM window
  CODEX_NOTIFY_THROTTLE=5      Suppress notifications within N seconds
  CODEX_NOTIFY_LOG=1           Append notifications to ~/.codex/notify.log
  CODEX_NOTIFY_LOG_FILE        Override log file path
  CODEX_NOTIFY_HOOK            Command to run on each notification event
  CODEX_NOTIFY_DEBUG=1         Show terminal-notifier output

https://github.com/paultendo/codex-notify
HELP
    exit 0
    ;;
  --test)
    exec "$0" '{"type":"agent-turn-complete","last-assistant-message":"Test notification from codex-notify","input-messages":["This is a test"],"thread-id":"test"}'
    ;;
  --test-say)
    CODEX_NOTIFY_SAY=1 exec "$0" '{"type":"agent-turn-complete","last-assistant-message":"Test notification from codex-notify","input-messages":["This is a test"],"thread-id":"test"}'
    ;;
  --test-approval)
    exec "$0" '{"type":"approval-required","last-assistant-message":"Waiting for approval","input-messages":["approve?"],"thread-id":"test"}'
    ;;
  --setup)
    self="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    config_dir="$HOME/.codex"
    config_file="$config_dir/config.toml"
    mkdir -p "$config_dir"
    if [[ -f "$config_file" ]] && grep -q '^notify' "$config_file"; then
      echo "notify hook already configured in $config_file"
    else
      printf '\nnotify = ["%s"]\n' "$self" >> "$config_file"
      echo "Added notify hook to $config_file"
    fi
    exit 0
    ;;
  --update)
    if ! command -v curl >/dev/null 2>&1; then
      echo "codex-notify: error: curl is required for --update" >&2
      exit 1
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "codex-notify: error: python3 is required for --update" >&2
      exit 1
    fi
    latest_tag="$(curl -s https://api.github.com/repos/paultendo/codex-notify/releases/latest \
      | python3 -c "import json,sys; print(json.loads(sys.stdin.read()).get('tag_name',''))" 2>/dev/null || true)"
    if [[ -z "$latest_tag" ]]; then
      echo "codex-notify: error: could not fetch latest release" >&2
      exit 1
    fi
    latest_ver="${latest_tag#v}"
    if [[ "$latest_ver" == "$VERSION" ]]; then
      echo "codex-notify $VERSION is already up to date."
      exit 0
    fi
    echo "Updating codex-notify $VERSION -> $latest_ver ..."
    tmpdir="$(mktemp -d)"
    trap 'rm -rf "$tmpdir"' EXIT
    curl -sL "https://github.com/paultendo/codex-notify/archive/refs/tags/${latest_tag}.tar.gz" \
      | tar xz -C "$tmpdir"
    installer="$(find "$tmpdir" -name install-codex-notify.sh -maxdepth 2 -print -quit 2>/dev/null)"
    if [[ -z "$installer" || ! -f "$installer" ]]; then
      echo "codex-notify: error: installer not found in release archive" >&2
      exit 1
    fi
    bash "$installer"
    echo "Updated to codex-notify $latest_ver"
    exit 0
    ;;
esac

payload="${1:-}"
title="Codex"
msg="Task finished"
subtitle=""
group=""
quiet="${CODEX_NOTIFY_QUIET:-0}"
sound="${CODEX_NOTIFY_SOUND:-/System/Library/Sounds/Glass.aiff}"
activate_bundle="${CODEX_ACTIVATE_BUNDLE:-com.microsoft.VSCode}"
sender_bundle="${CODEX_SENDER_BUNDLE:-com.microsoft.VSCode}"
suppress_frontmost="${CODEX_SUPPRESS_FRONTMOST:-1}"
exec_only="${CODEX_NOTIFY_EXEC_ONLY:-1}"
app_icon="${CODEX_NOTIFY_APP_ICON:-}"
exec_cmd="${CODEX_NOTIFY_EXEC_CMD:-}"
say_enabled="${CODEX_NOTIFY_SAY:-0}"
webhook_url="${CODEX_NOTIFY_WEBHOOK:-}"

if [[ -z "$app_icon" && "$activate_bundle" == "com.microsoft.VSCode" ]]; then
  default_icon="/Applications/Visual Studio Code.app/Contents/Resources/Code.icns"
  if [[ -f "$default_icon" ]]; then
    app_icon="$default_icon"
  fi
fi

if [[ -n "$app_icon" && "$app_icon" != http* && "$app_icon" != file://* ]]; then
  if [[ -f "$app_icon" ]]; then
    if command -v python3 >/dev/null 2>&1; then
      app_icon="$(python3 - "$app_icon" <<'PY'
from pathlib import Path
import sys

print(Path(sys.argv[1]).resolve().as_uri())
PY
)"
    else
      app_icon="file://$app_icon"
    fi
  fi
fi

# Resolve a bare sound name like "Glass" to the system sounds folder.
resolve_sound() {
  local s="$1"
  if [[ -n "$s" && "$s" != */* ]]; then
    local c="/System/Library/Sounds/${s}"
    if [[ -f "$c" ]]; then s="$c"
    elif [[ -f "${c}.aiff" ]]; then s="${c}.aiff"
    fi
  fi
  printf '%s' "$s"
}

sound="$(resolve_sound "$sound")"

if [[ -z "$exec_cmd" && -n "$activate_bundle" ]]; then
  exec_cmd="/usr/bin/open -b ${activate_bundle}"
fi

# Optional quiet mode: set CODEX_SILENT=1 to disable sound
if [[ "${CODEX_SILENT:-}" == "1" ]]; then
  sound=""
fi

if command -v osascript >/dev/null 2>&1; then
  front_bundle="$(osascript -e 'tell application "System Events" to get bundle identifier of first application process whose frontmost is true' 2>/dev/null || true)"
  # Auto-detect: if the Codex macOS app is frontmost, activate it instead of the default
  if [[ -n "$front_bundle" && "$front_bundle" == "com.openai.codex" && "$activate_bundle" != "com.openai.codex" ]]; then
    activate_bundle="com.openai.codex"
    exec_cmd="/usr/bin/open -b com.openai.codex"
  fi
  if [[ "$suppress_frontmost" != "0" && -n "$front_bundle" && "$front_bundle" == "$activate_bundle" ]]; then
    exit 0
  fi
fi

# DND / Focus awareness (opt-in)
if [[ "${CODEX_NOTIFY_DND:-0}" == "1" ]]; then
  dnd_active=0
  # macOS Monterey+: check Focus mode assertions
  dnd_assertions="$HOME/Library/DoNotDisturb/DB/Assertions.json"
  if [[ -f "$dnd_assertions" ]] && command -v python3 >/dev/null 2>&1; then
    dnd_active="$(python3 -c "
import json, sys
try:
    data = json.load(open(sys.argv[1]))
    stores = data.get('data', [])
    for store in stores:
        assertions = store.get('storeAssertionRecords', [])
        if assertions:
            print('1')
            sys.exit(0)
    print('0')
except Exception:
    print('0')
" "$dnd_assertions" 2>/dev/null || echo 0)"
  fi
  # Fallback: check via Notification Center pref (older macOS)
  if [[ "$dnd_active" == "0" ]]; then
    dnd_pref="$(defaults -currentHost read com.apple.notificationcenterui doNotDisturb 2>/dev/null || echo 0)"
    if [[ "$dnd_pref" == "1" ]]; then
      dnd_active=1
    fi
  fi
  if [[ "$dnd_active" == "1" ]]; then
    exit 0
  fi
fi

# Schedule awareness (opt-in)
notify_schedule="${CODEX_NOTIFY_SCHEDULE:-}"
if [[ -n "$notify_schedule" ]]; then
  sched_start="${notify_schedule%%-*}"
  sched_end="${notify_schedule##*-}"
  if [[ "$sched_start" =~ ^[0-9]{2}:[0-9]{2}$ && "$sched_end" =~ ^[0-9]{2}:[0-9]{2}$ ]]; then
    now_mins=$(( 10#$(date +%H) * 60 + 10#$(date +%M) ))
    start_mins=$(( 10#${sched_start%%:*} * 60 + 10#${sched_start##*:} ))
    end_mins=$(( 10#${sched_end%%:*} * 60 + 10#${sched_end##*:} ))
    in_window=0
    if [[ $start_mins -le $end_mins ]]; then
      # Normal range: e.g. 09:00-18:00
      if [[ $now_mins -ge $start_mins && $now_mins -lt $end_mins ]]; then
        in_window=1
      fi
    else
      # Overnight range: e.g. 22:00-06:00
      if [[ $now_mins -ge $start_mins || $now_mins -lt $end_mins ]]; then
        in_window=1
      fi
    fi
    if [[ "$in_window" == "0" ]]; then
      exit 0
    fi
  fi
fi

# Rate limiting / throttle (opt-in)
throttle_secs="${CODEX_NOTIFY_THROTTLE:-0}"
if [[ "$throttle_secs" -gt 0 ]] 2>/dev/null; then
  throttle_file="$HOME/.codex/.notify-last-ts"
  now_epoch="$(date +%s)"
  if [[ -f "$throttle_file" ]]; then
    last_epoch="$(cat "$throttle_file" 2>/dev/null || echo 0)"
    if [[ $(( now_epoch - last_epoch )) -lt $throttle_secs ]]; then
      exit 0
    fi
  fi
  mkdir -p "$HOME/.codex"
  printf '%s' "$now_epoch" > "$throttle_file"
fi

stderr_echo() {
  if [[ "$quiet" != "1" ]]; then
    local line="$title -- $msg"
    if [[ -n "$subtitle" ]]; then
      line="$title -- $msg ($subtitle)"
    fi
    printf '[%s] codex-notify: %s\n' "$(date +%H:%M:%S)" "$line" >&2
  fi
}

if [[ -n "$payload" && "$payload" == "{"* ]]; then
  if ! command -v python3 >/dev/null 2>&1; then
    echo "codex-notify: error: python3 required for JSON payloads" >&2
    exit 1
  fi
  parsed=()
  while IFS= read -r line; do
    parsed+=("$line")
  done < <(python3 - "$payload" <<'PY'
import json, sys
import os

def clean(val: object) -> str:
    s = "" if val is None else str(val)
    return " ".join(s.split())

def clip(s: str, limit: int) -> str:
    s = clean(s)
    return s if len(s) <= limit else s[: max(0, limit - 3) ] + "..."

try:
    payload = json.loads(sys.argv[1])
except Exception:
    sys.exit(1)

event_type = clean(payload.get("type", ""))
allow_env = os.environ.get("CODEX_NOTIFY_EVENT_TYPES", "*")
allowed = [s.strip() for s in allow_env.split(",") if s.strip()]
if not allowed:
    allowed = ["*"]
if allowed != ["*"] and event_type and event_type not in allowed:
    sys.exit(0)

last = clean(payload.get("last-assistant-message", "")) or "Turn complete"
title = f"Codex: {clip(last, 90)}"

inputs = payload.get("input-messages", [])
if isinstance(inputs, list):
    parts = []
    for item in inputs:
        if isinstance(item, str):
            parts.append(item)
        else:
            parts.append(json.dumps(item, ensure_ascii=True))
    inputs_text = " / ".join(parts)
else:
    inputs_text = str(inputs)

message = clip(inputs_text, 140) or "Turn complete"
cwd = clip(payload.get("cwd", ""), 140)
thread_id = clean(payload.get("thread-id", ""))
group = f"codex-{thread_id}" if thread_id else ""

category = "completion" if event_type == "agent-turn-complete" else "approval"

print(title)
print(message)
print(cwd)
print(group)
print(category)
PY
  )
  if [[ ${#parsed[@]} -eq 0 ]]; then
    exit 0
  fi
  title="${parsed[0]:-Codex}"
  msg="${parsed[1]:-Task finished}"
  subtitle="${parsed[2]:-}"
  group="${parsed[3]:-}"
  sound_category="${parsed[4]:-completion}"
  if [[ "$sound_category" == "approval" && "${CODEX_SILENT:-}" != "1" ]]; then
    approval_sound="${CODEX_NOTIFY_APPROVAL_SOUND:-/System/Library/Sounds/Sosumi.aiff}"
    sound="$(resolve_sound "$approval_sound")"
  fi
else
  if [[ -z "$payload" || "$payload" != "{"* ]]; then
    title="${1:-$title}"
    msg="${2:-$msg}"
    if [[ -n "${3:-}" ]]; then
      sound="${3}"
    fi
  fi
fi

stderr_echo

# Notification log (opt-in)
if [[ "${CODEX_NOTIFY_LOG:-0}" == "1" ]]; then
  log_file="${CODEX_NOTIFY_LOG_FILE:-$HOME/.codex/notify.log}"
  mkdir -p "$(dirname "$log_file")"
  log_line="$title -- $msg"
  if [[ -n "$subtitle" ]]; then
    log_line="$title -- $msg ($subtitle)"
  fi
  printf '[%s] [%s] %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "${sound_category:-completion}" "$log_line" >> "$log_file"
fi

tn_bin="$(command -v terminal-notifier 2>/dev/null || true)"
if [[ -z "$tn_bin" ]]; then
  for candidate in /opt/homebrew/bin/terminal-notifier /usr/local/bin/terminal-notifier; do
    if [[ -x "$candidate" ]]; then
      tn_bin="$candidate"
      break
    fi
  done
fi

notify_fallback() {
  local fallback_msg="$msg"
  if [[ -n "$subtitle" ]]; then
    fallback_msg="$msg - $subtitle"
  fi
  osascript -e "display notification \"$fallback_msg\" with title \"$title\"" \
    || echo "$title: $fallback_msg" >&2
}

if [[ -n "$tn_bin" ]]; then
  tn_args=(-title "$title" -message "$msg")
  if [[ -n "$subtitle" ]]; then
    tn_args+=(-subtitle "$subtitle")
  fi
  if [[ -n "$group" ]]; then
    tn_args+=(-group "$group")
  fi
  if [[ -n "$app_icon" ]]; then
    tn_args+=(-appIcon "$app_icon")
  fi
  if [[ -n "$activate_bundle" ]]; then
    if [[ "$exec_only" != "0" ]]; then
      if [[ -n "$exec_cmd" ]]; then
        tn_args+=(-execute "$exec_cmd")
      fi
    else
      tn_args+=(-activate "$activate_bundle")
    fi
  fi
  if [[ "$exec_only" == "0" && -n "$sender_bundle" ]]; then
    tn_args+=(-sender "$sender_bundle")
  fi
  tn_rc=0
  if [[ "${CODEX_NOTIFY_DEBUG:-}" == "1" ]]; then
    "$tn_bin" "${tn_args[@]}" || tn_rc=$?
  else
    "$tn_bin" "${tn_args[@]}" >/dev/null 2>&1 || tn_rc=$?
  fi
  if [[ $tn_rc -ne 0 ]]; then
    if [[ "${CODEX_NOTIFY_DEBUG:-}" == "1" ]]; then
      echo "$title: $msg" >&2
    fi
    notify_fallback
  fi
else
  notify_fallback
fi

if [[ "$say_enabled" == "1" && "${CODEX_SILENT:-}" != "1" ]]; then
  say_voice="${CODEX_NOTIFY_SAY_VOICE:-}"
  say_rate="${CODEX_NOTIFY_SAY_RATE:-}"
  say_text="$title"
  say_args=()
  if [[ -n "$say_voice" ]]; then
    say_args+=(-v "$say_voice")
  fi
  if [[ -n "$say_rate" ]]; then
    say_args+=(-r "$say_rate")
  fi
  say "${say_args[@]}" "$say_text" >/dev/null 2>&1 &
  disown
fi

if [[ -n "$webhook_url" ]]; then
  webhook_ts="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  if command -v python3 >/dev/null 2>&1; then
    webhook_body="$(python3 -c "
import json, sys
print(json.dumps({
    'content': sys.argv[1] + ' \u2014 ' + sys.argv[2],
    'title': sys.argv[1],
    'message': sys.argv[2],
    'category': sys.argv[3],
    'timestamp': sys.argv[4]
}))" "$title" "$msg" "${sound_category:-completion}" "$webhook_ts")"
  else
    webhook_body="{\"content\":\"$title\"}"
  fi
  curl -s -X POST -H "Content-Type: application/json" \
    -d "$webhook_body" "$webhook_url" >/dev/null 2>&1 &
  disown
fi

# Custom hook (opt-in)
notify_hook="${CODEX_NOTIFY_HOOK:-}"
if [[ -n "$notify_hook" ]]; then
  if [[ "${CODEX_NOTIFY_DEBUG:-}" == "1" ]]; then
    $notify_hook "$title" "$msg" "${sound_category:-completion}" &
  else
    $notify_hook "$title" "$msg" "${sound_category:-completion}" >/dev/null 2>&1 &
  fi
  disown
fi

if [[ -n "$sound" ]]; then
  afplay "$sound" >/dev/null 2>&1 &
  disown
fi
