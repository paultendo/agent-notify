#!/usr/bin/env bash
set -euo pipefail

VERSION="1.1.0"

# ---------------------------------------------------------------------------
# Platform detection
# ---------------------------------------------------------------------------
detect_platform() {
  case "$(uname -s 2>/dev/null)" in
    Darwin)                PLATFORM="macos" ;;
    Linux)                 PLATFORM="linux" ;;
    CYGWIN*|MINGW*|MSYS*) PLATFORM="windows" ;;
    *)                     PLATFORM="unknown" ;;
  esac
}
detect_platform

# ---------------------------------------------------------------------------
# CLI flags  (parsed before anything else)
# ---------------------------------------------------------------------------
case "${1:-}" in
  --version|-v|-V)
    echo "agent-notify $VERSION"
    exit 0
    ;;
  --help|-h)
    cat <<'HELP'
agent-notify - cross-platform notifications for AI coding agents

Supports: Codex CLI · Claude Code · Gemini CLI
Platforms: macOS · Linux · Windows (WSL / Git Bash)

Usage:
  agent-notify <json-payload>        Codex notify-hook mode (argv)
  echo '<json>' | agent-notify       Claude Code / Gemini CLI hook mode (stdin)
  agent-notify "Title" "Message"     Manual notification
  agent-notify --test                Codex completion notification
  agent-notify --test-approval       Codex approval notification
  agent-notify --test-claude         Claude Code completion notification
  agent-notify --test-claude-approval  Claude Code permission prompt
  agent-notify --test-gemini         Gemini CLI completion notification
  agent-notify --test-say            Completion with TTS
  agent-notify --test-bell           Terminal bell
  agent-notify --setup               Auto-configure all detected agents
  agent-notify --setup-codex         Configure Codex CLI only
  agent-notify --setup-claude        Configure Claude Code only
  agent-notify --setup-gemini        Configure Gemini CLI only
  agent-notify --update              Update to the latest release
  agent-notify --version             Print version
  agent-notify --help                Show this help

Environment variables:
  CODEX_NOTIFY_SOUND           Completion sound (default: Glass / complete.oga)
  CODEX_NOTIFY_APPROVAL_SOUND  Approval sound (default: Sosumi / dialog-warning.oga)
  CODEX_SILENT=1               Disable sound
  CODEX_NOTIFY_QUIET=1         Suppress terminal echo line
  CODEX_ACTIVATE_BUNDLE        macOS: app bundle to activate on click (auto-detected)
  CODEX_SENDER_BUNDLE          macOS: sender bundle for -activate mode icon
  CODEX_SUPPRESS_FRONTMOST     Set to 0 to always notify
  CODEX_NOTIFY_EVENT_TYPES     Event types to handle, comma-separated (default: *)
  CODEX_NOTIFY_EXEC_ONLY       Set to 0 for -activate instead of -execute (macOS)
  CODEX_NOTIFY_APP_ICON        Custom icon path or URL (macOS)
  CODEX_NOTIFY_SAY=1           Speak notification via TTS
  CODEX_NOTIFY_SAY_VOICE       Voice for TTS (e.g. Daniel, espeak voice)
  CODEX_NOTIFY_SAY_RATE        Speech rate (words per minute, macOS only)
  CODEX_NOTIFY_WEBHOOK         Webhook URL (Discord, Slack, Telegram, ntfy, generic)
  CODEX_NOTIFY_WEBHOOK_PRESET  Webhook format: slack, discord, telegram, ntfy, generic
  CODEX_NOTIFY_TELEGRAM_CHAT_ID  Telegram chat ID (required for telegram preset)
  CODEX_NOTIFY_NTFY_TOPIC      ntfy topic (can also be set via URL)
  CODEX_NOTIFY_EXEC_CMD        Override the click-execute command
  CODEX_NOTIFY_DND=1           Skip notification when Focus/DND is active
  CODEX_NOTIFY_SCHEDULE        Notify only during HH:MM-HH:MM window
  CODEX_NOTIFY_THROTTLE=5      Suppress notifications within N seconds
  CODEX_NOTIFY_LOG=1           Append notifications to ~/.codex/notify.log
  CODEX_NOTIFY_LOG_FILE        Override log file path
  CODEX_NOTIFY_HOOK            Command to run on each notification event
  CODEX_NOTIFY_DEBUG=1         Show debug output
  CODEX_NOTIFY_BELL            Terminal bell: 0=off, 1=always, auto=headless (default: auto)
  CODEX_NOTIFY_MIN_DURATION=N  Only notify if N+ seconds since session start
  CODEX_NOTIFY_ACTIVATE_CMD    Linux/Windows: command to focus the editor window
  CODEX_NOTIFY_GIT_BRANCH=1    Show git branch in notification (default: 1)

Per-project: place a .agent-notify.env in your project root to override any
CODEX_NOTIFY_* variable for that repo.

https://github.com/paultendo/agent-notify
HELP
    exit 0
    ;;
  --test)
    exec "$0" '{"type":"agent-turn-complete","last-assistant-message":"Test notification from agent-notify","input-messages":["This is a test"],"thread-id":"test","cwd":"'"$PWD"'"}'
    ;;
  --test-say)
    CODEX_NOTIFY_SAY=1 exec "$0" '{"type":"agent-turn-complete","last-assistant-message":"Test notification from agent-notify","input-messages":["This is a test"],"thread-id":"test","cwd":"'"$PWD"'"}'
    ;;
  --test-approval)
    exec "$0" '{"type":"approval-required","last-assistant-message":"Waiting for approval","input-messages":["approve?"],"thread-id":"test","cwd":"'"$PWD"'"}'
    ;;
  --test-bell)
    printf '\a' >&2
    echo "agent-notify: terminal bell sent" >&2
    exit 0
    ;;
  --test-claude)
    echo '{"hook_event_name":"Stop","session_id":"test-claude","cwd":"'"$PWD"'","last_assistant_message":"Test Claude Code notification from agent-notify"}' \
      | "$0"
    exit $?
    ;;
  --test-claude-approval)
    echo '{"hook_event_name":"Notification","session_id":"test-claude","cwd":"'"$PWD"'","notification":{"type":"permission_prompt","title":"Permission needed","message":"Claude wants to run a command"}}' \
      | "$0"
    exit $?
    ;;
  --test-gemini)
    echo '{"hook_event_name":"AfterAgent","session_id":"test-gemini","cwd":"'"$PWD"'","prompt_response":"Test Gemini CLI notification from agent-notify"}' \
      | "$0"
    exit $?
    ;;
  --setup)
    self="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    any_configured=0
    # Codex CLI
    "$self" --setup-codex && any_configured=1
    # Claude Code
    "$self" --setup-claude && any_configured=1
    # Gemini CLI
    "$self" --setup-gemini && any_configured=1
    if [[ "$any_configured" == "0" ]]; then
      echo "agent-notify: no agents configured" >&2
    fi
    exit 0
    ;;
  --setup-codex)
    self="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    config_dir="$HOME/.codex"
    config_file="$config_dir/config.toml"
    mkdir -p "$config_dir"
    if [[ -f "$config_file" ]] && grep -q '^notify' "$config_file"; then
      echo "Codex CLI: notify hook already configured in $config_file"
    else
      printf '\nnotify = ["%s"]\n' "$self" >> "$config_file"
      echo "Codex CLI: added notify hook to $config_file"
    fi
    exit 0
    ;;
  --setup-claude)
    self="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    config_file="$HOME/.claude/settings.json"
    if ! command -v python3 >/dev/null 2>&1; then
      echo "agent-notify: error: python3 required for Claude Code setup" >&2
      exit 1
    fi
    mkdir -p "$HOME/.claude"
    if [[ -f "$config_file" ]]; then
      cp "$config_file" "${config_file}.bak"
    fi
    python3 - "$self" "$config_file" <<'PYSETUP'
import json, sys, os

script_path = sys.argv[1]
config_path = sys.argv[2]

settings = {}
if os.path.exists(config_path):
    with open(config_path) as f:
        try:
            settings = json.load(f)
        except json.JSONDecodeError:
            settings = {}

hooks = settings.setdefault("hooks", {})
hook_list = hooks.setdefault("Stop", [])

# Check if already configured
already = any(
    isinstance(h, dict) and script_path in h.get("command", "")
    for h in hook_list
)
if already:
    print(f"Claude Code: hooks already configured in {config_path}")
    sys.exit(0)

# Add Stop hook (task completion)
hook_list.append({
    "type": "command",
    "command": script_path
})

# Add Notification hook (permission prompts, idle, etc.)
notif_list = hooks.setdefault("Notification", [])
notif_already = any(
    isinstance(h, dict) and script_path in h.get("command", "")
    for h in notif_list
)
if not notif_already:
    notif_list.append({
        "type": "command",
        "command": script_path
    })

with open(config_path, "w") as f:
    json.dump(settings, f, indent=2)
    f.write("\n")

print(f"Claude Code: added hooks to {config_path}")
PYSETUP
    exit 0
    ;;
  --setup-gemini)
    self="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    config_file="$HOME/.gemini/settings.json"
    if ! command -v python3 >/dev/null 2>&1; then
      echo "agent-notify: error: python3 required for Gemini CLI setup" >&2
      exit 1
    fi
    mkdir -p "$HOME/.gemini"
    if [[ -f "$config_file" ]]; then
      cp "$config_file" "${config_file}.bak"
    fi
    python3 - "$self" "$config_file" <<'PYSETUP'
import json, sys, os

script_path = sys.argv[1]
config_path = sys.argv[2]

settings = {}
if os.path.exists(config_path):
    with open(config_path) as f:
        try:
            settings = json.load(f)
        except json.JSONDecodeError:
            settings = {}

# Enable hooks
tools = settings.setdefault("tools", {})
tools["enableHooks"] = True
hooks_config = settings.setdefault("hooks", {})
hooks_config["enabled"] = True

hook_list = hooks_config.setdefault("AfterAgent", [])

# Check if already configured
already = any(
    isinstance(h, dict) and script_path in h.get("command", "")
    for h in hook_list
)
if already:
    print(f"Gemini CLI: hooks already configured in {config_path}")
    sys.exit(0)

# Add AfterAgent hook (task completion)
hook_list.append({
    "name": "agent-notify",
    "description": "Send desktop notification when agent finishes",
    "command": script_path,
    "timeout": 10000
})

# Add Notification hook
notif_list = hooks_config.setdefault("Notification", [])
notif_already = any(
    isinstance(h, dict) and script_path in h.get("command", "")
    for h in notif_list
)
if not notif_already:
    notif_list.append({
        "name": "agent-notify",
        "description": "Send desktop notification for permission prompts",
        "command": script_path,
        "timeout": 10000
    })

with open(config_path, "w") as f:
    json.dump(settings, f, indent=2)
    f.write("\n")

print(f"Gemini CLI: added hooks to {config_path}")
PYSETUP
    exit 0
    ;;
  --update)
    if ! command -v curl >/dev/null 2>&1; then
      echo "agent-notify: error: curl is required for --update" >&2
      exit 1
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "agent-notify: error: python3 is required for --update" >&2
      exit 1
    fi
    latest_tag="$(curl -s https://api.github.com/repos/paultendo/agent-notify/releases/latest \
      | python3 -c "import json,sys; print(json.loads(sys.stdin.read()).get('tag_name',''))" 2>/dev/null || true)"
    if [[ -z "$latest_tag" ]]; then
      echo "agent-notify: error: could not fetch latest release" >&2
      exit 1
    fi
    latest_ver="${latest_tag#v}"
    if [[ "$latest_ver" == "$VERSION" ]]; then
      echo "agent-notify $VERSION is already up to date."
      exit 0
    fi
    echo "Updating agent-notify $VERSION -> $latest_ver ..."
    tmpdir="$(mktemp -d)"
    trap 'rm -rf "$tmpdir"' EXIT
    curl -sL "https://github.com/paultendo/agent-notify/archive/refs/tags/${latest_tag}.tar.gz" \
      | tar xz -C "$tmpdir"
    installer="$(find "$tmpdir" -name install-agent-notify.sh -maxdepth 2 -print -quit 2>/dev/null)"
    if [[ -z "$installer" || ! -f "$installer" ]]; then
      echo "agent-notify: error: installer not found in release archive" >&2
      exit 1
    fi
    bash "$installer"
    echo "Updated to agent-notify $latest_ver"
    exit 0
    ;;
esac

# ---------------------------------------------------------------------------
# Read stdin (for Claude Code / Gemini CLI hooks)
# IMPORTANT: never write to stdout — Claude Code and Gemini CLI parse it
# ---------------------------------------------------------------------------
stdin_json=""
if [[ ! -t 0 ]]; then
  stdin_json="$(cat)"
fi

# ---------------------------------------------------------------------------
# Per-project config: source .agent-notify.env from cwd if available
# (falls back to .codex-notify.env for backwards compatibility)
# ---------------------------------------------------------------------------
_source_project_env() {
  local dir="$1"
  local env_file=""
  if [[ -n "$dir" && -f "$dir/.agent-notify.env" ]]; then
    env_file="$dir/.agent-notify.env"
  elif [[ -n "$dir" && -f "$dir/.codex-notify.env" ]]; then
    env_file="$dir/.codex-notify.env"
  fi
  if [[ -n "$env_file" ]]; then
    # Only source CODEX_NOTIFY_* and CODEX_SILENT lines for safety
    while IFS= read -r line; do
      case "$line" in
        CODEX_NOTIFY_*=*|CODEX_SILENT=*) eval "export $line" ;;
      esac
    done < "$env_file"
  fi
}

# ---------------------------------------------------------------------------
# Git branch detection
# ---------------------------------------------------------------------------
_get_git_branch() {
  local dir="$1"
  if [[ -z "$dir" ]]; then return; fi
  local branch
  branch="$(git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
  if [[ -n "$branch" && "$branch" != "HEAD" ]]; then
    printf '%s' "$branch"
  fi
}

# ---------------------------------------------------------------------------
# Terminal / multiplexer detection (macOS)
# ---------------------------------------------------------------------------
_detect_terminal_bundle() {
  # Priority: CODEX_ACTIVATE_BUNDLE > __CFBundleIdentifier > TERM_PROGRAM > tmux env > fallback
  if [[ -n "${CODEX_ACTIVATE_BUNDLE:-}" ]]; then
    printf '%s' "$CODEX_ACTIVATE_BUNDLE"
    return
  fi
  # __CFBundleIdentifier is set by Warp and some other terminals
  if [[ -n "${__CFBundleIdentifier:-}" ]]; then
    printf '%s' "$__CFBundleIdentifier"
    return
  fi
  local tp="${TERM_PROGRAM:-}"
  case "$tp" in
    iTerm.app)       printf 'com.googlecode.iterm2' ;;
    Apple_Terminal)  printf 'com.apple.Terminal' ;;
    vscode)          printf 'com.microsoft.VSCode' ;;
    WezTerm)         printf 'com.github.wez.wezterm' ;;
    Alacritty)       printf 'org.alacritty' ;;
    Hyper)           printf 'co.zeit.hyper' ;;
    WarpTerminal)    printf 'dev.warp.Warp-Stable' ;;
    *)
      # Inside tmux? Try to get TERM_PROGRAM from tmux environment
      if [[ -n "${TMUX:-}" ]]; then
        local tmux_tp
        tmux_tp="$(tmux show-environment TERM_PROGRAM 2>/dev/null | sed 's/^TERM_PROGRAM=//' || true)"
        case "$tmux_tp" in
          iTerm.app)       printf 'com.googlecode.iterm2' ;;
          vscode)          printf 'com.microsoft.VSCode' ;;
          WezTerm)         printf 'com.github.wez.wezterm' ;;
          Alacritty)       printf 'org.alacritty' ;;
          WarpTerminal)    printf 'dev.warp.Warp-Stable' ;;
          *)               printf 'com.microsoft.VSCode' ;;
        esac
      elif [[ -n "${GHOSTTY_RESOURCES_DIR:-}" ]]; then
        printf 'com.mitchellh.ghostty'
      elif [[ -n "${KITTY_WINDOW_ID:-}" ]]; then
        printf 'net.kovidgoyal.kitty'
      elif [[ -n "${ITERM_SESSION_ID:-}" ]]; then
        printf 'com.googlecode.iterm2'
      elif [[ -n "${WEZTERM_PANE:-}" ]]; then
        printf 'com.github.wez.wezterm'
      else
        printf 'com.microsoft.VSCode'
      fi
      ;;
  esac
}

# Build the click-to-focus execute command for terminal-notifier
_build_exec_cmd() {
  local bundle="$1"
  local cwd="${2:-}"

  # User override takes priority
  if [[ -n "${CODEX_NOTIFY_EXEC_CMD:-}" ]]; then
    printf '%s' "$CODEX_NOTIFY_EXEC_CMD"
    return
  fi

  # --- Multiplexer focus commands (macOS) ---
  # tmux: select the right window and pane
  if [[ -n "${TMUX:-}" ]]; then
    local pane_id tmux_bin socket_path
    pane_id="$(tmux display-message -p '#{pane_id}' 2>/dev/null || true)"
    tmux_bin="$(command -v tmux 2>/dev/null || echo tmux)"
    # TMUX format: "/private/tmp/tmux-501/default,12345,0"
    socket_path="${TMUX%%,*}"
    if [[ -n "$pane_id" && -n "$socket_path" ]]; then
      printf "'%s' -S '%s' select-window -t '%s' \\; select-pane -t '%s'" \
        "$tmux_bin" "$socket_path" "$pane_id" "$pane_id"
      return
    fi
  fi

  # zellij: focus the active tab
  if [[ -n "${ZELLIJ:-}" ]]; then
    local zellij_bin session_name tab_name
    zellij_bin="$(command -v zellij 2>/dev/null || echo zellij)"
    session_name="${ZELLIJ_SESSION_NAME:-}"
    if [[ -n "$session_name" ]]; then
      # Get active tab name from layout dump
      tab_name="$(zellij action dump-layout 2>/dev/null \
        | grep -E '^\s*tab\b.*focus=true' \
        | sed -n 's/.*name="\([^"]*\)".*/\1/p' || true)"
      if [[ -n "$tab_name" ]]; then
        printf "'%s' -s '%s' action go-to-tab-name '%s'" \
          "$zellij_bin" "$session_name" "$tab_name"
        return
      fi
    fi
  fi

  # kitty: focus the right window via remote control
  if [[ -n "${KITTY_WINDOW_ID:-}" && -n "${KITTY_LISTEN_ON:-}" ]]; then
    local kitty_bin
    kitty_bin="$(command -v kitty 2>/dev/null || echo kitty)"
    printf "'%s' @ --to '%s' focus-window --match id:%s" \
      "$kitty_bin" "$KITTY_LISTEN_ON" "$KITTY_WINDOW_ID"
    return
  fi

  # WezTerm: focus the right pane
  if [[ -n "${WEZTERM_PANE:-}" ]]; then
    local wezterm_bin
    wezterm_bin="$(command -v wezterm 2>/dev/null || echo wezterm)"
    if [[ -n "${WEZTERM_UNIX_SOCKET:-}" ]]; then
      printf "'%s' cli activate-pane --pane-id %s --unix-socket '%s'" \
        "$wezterm_bin" "$WEZTERM_PANE" "$WEZTERM_UNIX_SOCKET"
    else
      printf "'%s' cli activate-pane --pane-id %s" "$wezterm_bin" "$WEZTERM_PANE"
    fi
    return
  fi

  # --- Standard terminal focus (macOS) ---
  # Use System Events to find the right window by folder name in the title.
  # This works for all apps (including Electron apps like VS Code) as long as
  # the user has granted accessibility access.  We target the process by bundle
  # identifier so it works regardless of the process display name.
  local folder_name=""
  if [[ -n "$cwd" ]]; then
    folder_name="${cwd##*/}"
  fi

  if [[ -n "$folder_name" ]]; then
    local safe_bundle safe_folder
    safe_bundle="${bundle//\\/\\\\}"
    safe_bundle="${safe_bundle//\"/\\\"}"
    safe_folder="${folder_name//\\/\\\\}"
    safe_folder="${safe_folder//\"/\\\"}"
    printf "osascript -e 'tell application \"System Events\"' -e 'tell (first process whose bundle identifier is \"%s\")' -e 'set _n to \"%s\"' -e 'repeat with w in windows' -e 'if name of w contains _n then' -e 'perform action \"AXRaise\" of w' -e 'exit repeat' -e 'end if' -e 'end repeat' -e 'end tell' -e 'end tell' -e 'tell application id \"%s\" to activate'" \
      "$safe_bundle" "$safe_folder" "$safe_bundle"
    return
  fi

  # Default: just open the app
  printf '/usr/bin/open -b %s' "$bundle"
}

# ---------------------------------------------------------------------------
# Determine payload source and parse
# ---------------------------------------------------------------------------
payload="${1:-}"
title=""
msg="Task finished"
subtitle=""
group=""
sound_category="completion"
agent_name=""
session_id=""
project_cwd=""

if [[ -n "$stdin_json" && "$stdin_json" == "{"* ]]; then
  # ---- stdin JSON: Claude Code or Gemini CLI ----
  if ! command -v python3 >/dev/null 2>&1; then
    echo "agent-notify: error: python3 required for JSON payloads" >&2
    exit 1
  fi
  parsed=()
  while IFS= read -r line; do
    parsed+=("$line")
  done < <(python3 - "$stdin_json" <<'PY'
import json, sys

def clean(val):
    s = "" if val is None else str(val)
    return " ".join(s.split())

def clip(s, limit):
    s = clean(s)
    return s if len(s) <= limit else s[:max(0, limit - 3)] + "..."

try:
    data = json.loads(sys.argv[1])
except Exception:
    sys.exit(1)

hook_event = clean(data.get("hook_event_name", ""))
if not hook_event:
    sys.exit(1)

# Detect agent from payload shape
# Claude Code: has "last_assistant_message", "tool_name", or nested "notification" dict
# Gemini CLI: has "prompt_response"
has_gemini = "prompt_response" in data
notif = data.get("notification", {})
has_claude = (
    "last_assistant_message" in data
    or "tool_name" in data
    or (isinstance(notif, dict) and notif.get("type") in (
        "permission_prompt", "idle_prompt", "auth_success", "elicitation_dialog"
    ))
)

if has_gemini:
    agent = "Gemini"
    last = clean(data.get("prompt_response", "")) or "Task complete"
elif has_claude:
    agent = "Claude"
    last = clean(data.get("last_assistant_message", "")) or "Task complete"
else:
    # Unknown stdin agent — try best guess
    agent = "Agent"
    last = clean(data.get("last_assistant_message", data.get("prompt_response", ""))) or "Task complete"

title = f"{agent}: {clip(last, 90)}"
cwd = clean(data.get("cwd", ""))
sid = clean(data.get("session_id", ""))
group = f"{agent.lower()}-{sid}" if sid else ""

# Categorize event with fine-grained types
# Categories: completion, approval, question, error, auth
category = "completion"
if hook_event == "Notification":
    # Default to approval for notification events
    category = "approval"
    if isinstance(notif, dict):
        notif_type = clean(notif.get("type", ""))
        notif_title = clean(notif.get("title", ""))
        notif_msg = clean(notif.get("message", ""))

        # Fine-grained categorization
        if notif_type == "permission_prompt":
            category = "approval"
        elif notif_type == "idle_prompt":
            category = "question"
        elif notif_type == "elicitation_dialog":
            category = "question"
        elif notif_type == "auth_success":
            category = "auth"

        if notif_title:
            title = f"{agent}: {clip(notif_title, 90)}"
        if notif_msg:
            last = notif_msg

        # Gemini ToolPermission
        if notif_type == "ToolPermission" or "ToolPermission" in notif_title:
            category = "approval"

elif hook_event in ("Stop", "AfterAgent"):
    category = "completion"

    # Detect error conditions from message content (Claude Code)
    if has_claude and last:
        lower_last = last.lower()
        if "session limit" in lower_last or "session limit has been reached" in lower_last:
            category = "error"
            title = f"{agent}: Session limit reached"
        elif ("401" in lower_last and ("authentication" in lower_last or "/login" in lower_last)):
            category = "error"
            title = f"{agent}: Auth error (401)"
        elif "api error" in lower_last or "overloaded" in lower_last:
            category = "error"

message = clip(last, 140)

# Trim cwd for subtitle
cwd_display = clip(cwd, 140)

print(title)
print(message)
print(cwd_display)
print(group)
print(category)
print(agent)
print(sid)
print(cwd)
PY
  )
  if [[ ${#parsed[@]} -eq 0 ]]; then
    exit 0
  fi
  title="${parsed[0]:-Agent}"
  msg="${parsed[1]:-Task finished}"
  subtitle="${parsed[2]:-}"
  group="${parsed[3]:-}"
  sound_category="${parsed[4]:-completion}"
  agent_name="${parsed[5]:-}"
  session_id="${parsed[6]:-}"
  project_cwd="${parsed[7]:-}"

elif [[ -n "$payload" && "$payload" == "{"* ]]; then
  # ---- argv JSON: Codex CLI ----
  if ! command -v python3 >/dev/null 2>&1; then
    echo "agent-notify: error: python3 required for JSON payloads" >&2
    exit 1
  fi
  parsed=()
  while IFS= read -r line; do
    parsed+=("$line")
  done < <(python3 - "$payload" <<'PY'
import json, sys
import os

def clean(val):
    s = "" if val is None else str(val)
    return " ".join(s.split())

def clip(s, limit):
    s = clean(s)
    return s if len(s) <= limit else s[:max(0, limit - 3)] + "..."

try:
    payload = json.loads(sys.argv[1])
except Exception:
    sys.exit(1)

event_type = clean(payload.get("type", ""))
allow_env = os.environ.get("CODEX_NOTIFY_EVENT_TYPES", "*")
allowed = [s.strip() for s in allow_env.split(",") if s.strip()]
if not allowed:
    allowed = ["*"]
if allowed != ["*"] and event_type and event_type not in allowed:
    sys.exit(0)

last = clean(payload.get("last-assistant-message", "")) or "Turn complete"
title = f"Codex: {clip(last, 90)}"

inputs = payload.get("input-messages", [])
if isinstance(inputs, list):
    parts = []
    for item in inputs:
        if isinstance(item, str):
            parts.append(item)
        else:
            parts.append(json.dumps(item, ensure_ascii=True))
    inputs_text = " / ".join(parts)
else:
    inputs_text = str(inputs)

message = clip(inputs_text, 140) or "Turn complete"
cwd = clean(payload.get("cwd", ""))
cwd_display = clip(cwd, 140)
thread_id = clean(payload.get("thread-id", ""))
group = f"codex-{thread_id}" if thread_id else ""

category = "completion" if event_type == "agent-turn-complete" else "approval"

print(title)
print(message)
print(cwd_display)
print(group)
print(category)
print("Codex")
print(thread_id)
print(cwd)
PY
  )
  if [[ ${#parsed[@]} -eq 0 ]]; then
    exit 0
  fi
  title="${parsed[0]:-Codex}"
  msg="${parsed[1]:-Task finished}"
  subtitle="${parsed[2]:-}"
  group="${parsed[3]:-}"
  sound_category="${parsed[4]:-completion}"
  agent_name="${parsed[5]:-Codex}"
  session_id="${parsed[6]:-}"
  project_cwd="${parsed[7]:-}"

else
  # ---- Manual title/message mode ----
  title="${1:-Codex}"
  msg="${2:-Task finished}"
  agent_name="Manual"
  if [[ -n "${3:-}" ]]; then
    # Legacy: third arg was custom sound
    export CODEX_NOTIFY_SOUND="${3}"
  fi
fi

# Extract project cwd (raw, unclipped) for git branch and per-project config
if [[ -z "$project_cwd" ]]; then
  project_cwd="${subtitle}"
fi
# Source per-project config
_source_project_env "${project_cwd:-$PWD}"

# ---------------------------------------------------------------------------
# Load configuration (after per-project env so overrides take effect)
# ---------------------------------------------------------------------------
quiet="${CODEX_NOTIFY_QUIET:-0}"
sender_bundle="${CODEX_SENDER_BUNDLE:-com.microsoft.VSCode}"
suppress_frontmost="${CODEX_SUPPRESS_FRONTMOST:-1}"
exec_only="${CODEX_NOTIFY_EXEC_ONLY:-1}"
app_icon="${CODEX_NOTIFY_APP_ICON:-}"
say_enabled="${CODEX_NOTIFY_SAY:-0}"
webhook_url="${CODEX_NOTIFY_WEBHOOK:-}"
webhook_preset="${CODEX_NOTIFY_WEBHOOK_PRESET:-}"
bell_mode="${CODEX_NOTIFY_BELL:-auto}"
min_duration="${CODEX_NOTIFY_MIN_DURATION:-0}"
activate_cmd="${CODEX_NOTIFY_ACTIVATE_CMD:-}"
show_git_branch="${CODEX_NOTIFY_GIT_BRANCH:-1}"

# Auto-detect terminal and build exec command (macOS)
if [[ "$PLATFORM" == "macos" ]]; then
  activate_bundle="$(_detect_terminal_bundle)"
  exec_cmd="$(_build_exec_cmd "$activate_bundle" "${project_cwd:-$PWD}")"
else
  activate_bundle="${CODEX_ACTIVATE_BUNDLE:-com.microsoft.VSCode}"
  exec_cmd="${CODEX_NOTIFY_EXEC_CMD:-}"
fi

# ---------------------------------------------------------------------------
# Git branch: append to subtitle
# ---------------------------------------------------------------------------
if [[ "$show_git_branch" == "1" ]]; then
  git_branch="$(_get_git_branch "${project_cwd:-$PWD}")"
  if [[ -n "$git_branch" ]]; then
    if [[ -n "$subtitle" ]]; then
      subtitle="$subtitle [$git_branch]"
    else
      subtitle="[$git_branch]"
    fi
  fi
fi

# ---------------------------------------------------------------------------
# Platform-specific: resolve default sounds
# ---------------------------------------------------------------------------
resolve_sound() {
  local s="$1"
  if [[ -z "$s" ]]; then
    printf '%s' "$s"
    return
  fi
  case "$PLATFORM" in
    macos)
      if [[ "$s" != */* ]]; then
        local c="/System/Library/Sounds/${s}"
        if [[ -f "$c" ]]; then s="$c"
        elif [[ -f "${c}.aiff" ]]; then s="${c}.aiff"
        fi
      fi
      ;;
    linux)
      if [[ "$s" != */* ]]; then
        # Try freedesktop sound theme
        for dir in /usr/share/sounds/freedesktop/stereo /usr/share/sounds/gnome/default/alerts; do
          if [[ -f "$dir/${s}.oga" ]]; then s="$dir/${s}.oga"; break; fi
          if [[ -f "$dir/${s}.ogg" ]]; then s="$dir/${s}.ogg"; break; fi
          if [[ -f "$dir/${s}.wav" ]]; then s="$dir/${s}.wav"; break; fi
        done
      fi
      ;;
    windows)
      if [[ "$s" != */* && "$s" != *\\* ]]; then
        local windir
        windir="$(cmd.exe /c 'echo %WINDIR%' 2>/dev/null | tr -d '\r' || echo 'C:\Windows')"
        local media="${windir}\\Media\\${s}.wav"
        s="$media"
      fi
      ;;
  esac
  printf '%s' "$s"
}

_default_completion_sound() {
  case "$PLATFORM" in
    macos)   echo "Glass" ;;
    linux)   echo "complete" ;;
    windows) echo "Windows Notify System Generic" ;;
    *)       echo "" ;;
  esac
}

_default_approval_sound() {
  case "$PLATFORM" in
    macos)   echo "Sosumi" ;;
    linux)   echo "dialog-warning" ;;
    windows) echo "Windows Notify Calendar" ;;
    *)       echo "" ;;
  esac
}

# Map fine-grained categories to sound categories
_sound_for_category() {
  case "$1" in
    completion|auth)  echo "completion" ;;
    approval|question|error) echo "approval" ;;
    *)                echo "completion" ;;
  esac
}

sound_type="$(_sound_for_category "$sound_category")"

sound="${CODEX_NOTIFY_SOUND:-$(_default_completion_sound)}"
sound="$(resolve_sound "$sound")"

if [[ "$sound_type" == "approval" && "${CODEX_SILENT:-}" != "1" ]]; then
  approval_sound="${CODEX_NOTIFY_APPROVAL_SOUND:-$(_default_approval_sound)}"
  sound="$(resolve_sound "$approval_sound")"
fi

if [[ "${CODEX_SILENT:-}" == "1" ]]; then
  sound=""
fi

# ---------------------------------------------------------------------------
# Platform-specific: icon resolution (macOS only)
# ---------------------------------------------------------------------------
if [[ "$PLATFORM" == "macos" ]]; then
  if [[ -z "$app_icon" && "$activate_bundle" == "com.microsoft.VSCode" ]]; then
    default_icon="/Applications/Visual Studio Code.app/Contents/Resources/Code.icns"
    if [[ -f "$default_icon" ]]; then
      app_icon="$default_icon"
    fi
  fi

  if [[ -n "$app_icon" && "$app_icon" != http* && "$app_icon" != file://* ]]; then
    if [[ -f "$app_icon" ]]; then
      if command -v python3 >/dev/null 2>&1; then
        app_icon="$(python3 - "$app_icon" <<'PY'
from pathlib import Path
import sys
print(Path(sys.argv[1]).resolve().as_uri())
PY
)"
      else
        app_icon="file://$app_icon"
      fi
    fi
  fi
fi

# ---------------------------------------------------------------------------
# Platform-specific: frontmost app detection + auto-detect Codex macOS app
# ---------------------------------------------------------------------------
get_frontmost_app() {
  case "$PLATFORM" in
    macos)
      osascript -e 'tell application "System Events" to get bundle identifier of first application process whose frontmost is true' 2>/dev/null || true
      ;;
    linux)
      if command -v xdotool >/dev/null 2>&1; then
        local wid
        wid="$(xdotool getactivewindow 2>/dev/null || true)"
        if [[ -n "$wid" ]]; then
          xdotool getactivewindow getwindowname 2>/dev/null || true
        fi
      fi
      ;;
    windows)
      # shellcheck disable=SC2016
      powershell.exe -NoProfile -Command '
        Add-Type -Name Win -Namespace Native -MemberDefinition "[DllImport(\"user32.dll\")] public static extern IntPtr GetForegroundWindow();"
        $h = [Native.Win]::GetForegroundWindow()
        Get-Process | Where-Object { $_.MainWindowHandle -eq $h } | Select-Object -ExpandProperty ProcessName
      ' 2>/dev/null | tr -d '\r' || true
      ;;
  esac
}

if [[ "$PLATFORM" == "macos" ]]; then
  front_bundle="$(get_frontmost_app)"
  # Auto-detect: if the Codex macOS app is frontmost, activate it instead
  if [[ -n "$front_bundle" && "$front_bundle" == "com.openai.codex" && "$activate_bundle" != "com.openai.codex" ]]; then
    activate_bundle="com.openai.codex"
    exec_cmd="/usr/bin/open -b com.openai.codex"
  fi
  if [[ "$suppress_frontmost" != "0" && -n "$front_bundle" && "$front_bundle" == "$activate_bundle" ]]; then
    exit 0
  fi
fi

# ---------------------------------------------------------------------------
# DND / Focus awareness (opt-in)
# ---------------------------------------------------------------------------
check_dnd() {
  case "$PLATFORM" in
    macos)
      local dnd_active=0
      local dnd_assertions="$HOME/Library/DoNotDisturb/DB/Assertions.json"
      if [[ -f "$dnd_assertions" ]] && command -v python3 >/dev/null 2>&1; then
        dnd_active="$(python3 -c "
import json, sys
try:
    data = json.load(open(sys.argv[1]))
    stores = data.get('data', [])
    for store in stores:
        assertions = store.get('storeAssertionRecords', [])
        if assertions:
            print('1')
            sys.exit(0)
    print('0')
except Exception:
    print('0')
" "$dnd_assertions" 2>/dev/null || echo 0)"
      fi
      if [[ "$dnd_active" == "0" ]]; then
        local dnd_pref
        dnd_pref="$(defaults -currentHost read com.apple.notificationcenterui doNotDisturb 2>/dev/null || echo 0)"
        if [[ "$dnd_pref" == "1" ]]; then
          dnd_active=1
        fi
      fi
      echo "$dnd_active"
      ;;
    linux)
      # Check dunst / sway / GNOME DND status
      if command -v dunstctl >/dev/null 2>&1; then
        if dunstctl is-paused 2>/dev/null | grep -q "true"; then
          echo "1"; return
        fi
      fi
      if command -v dbus-send >/dev/null 2>&1; then
        local gnome_dnd
        gnome_dnd="$(dbus-send --session --print-reply --dest=org.gnome.Shell \
          /org/gnome/Shell org.freedesktop.DBus.Properties.Get \
          string:'org.gnome.Shell' string:'DoNotDisturb' 2>/dev/null | grep -o 'true\|false' || true)"
        if [[ "$gnome_dnd" == "true" ]]; then
          echo "1"; return
        fi
      fi
      echo "0"
      ;;
    windows)
      local focus
      # shellcheck disable=SC2016
      focus="$(powershell.exe -NoProfile -Command '
        try {
          $val = Get-ItemPropertyValue "HKCU:\Software\Microsoft\Windows\CurrentVersion\Notifications\Settings" -Name "NOC_GLOBAL_SETTING_TOASTS_ENABLED" -ErrorAction Stop
          if ($val -eq 0) { Write-Output "1" } else { Write-Output "0" }
        } catch { Write-Output "0" }
      ' 2>/dev/null | tr -d '\r' || echo 0)"
      echo "$focus"
      ;;
    *)
      echo "0"
      ;;
  esac
}

if [[ "${CODEX_NOTIFY_DND:-0}" == "1" ]]; then
  if [[ "$(check_dnd)" == "1" ]]; then
    exit 0
  fi
fi

# ---------------------------------------------------------------------------
# Schedule awareness (opt-in)
# ---------------------------------------------------------------------------
notify_schedule="${CODEX_NOTIFY_SCHEDULE:-}"
if [[ -n "$notify_schedule" ]]; then
  sched_start="${notify_schedule%%-*}"
  sched_end="${notify_schedule##*-}"
  if [[ "$sched_start" =~ ^[0-9]{2}:[0-9]{2}$ && "$sched_end" =~ ^[0-9]{2}:[0-9]{2}$ ]]; then
    now_mins=$(( 10#$(date +%H) * 60 + 10#$(date +%M) ))
    start_mins=$(( 10#${sched_start%%:*} * 60 + 10#${sched_start##*:} ))
    end_mins=$(( 10#${sched_end%%:*} * 60 + 10#${sched_end##*:} ))
    in_window=0
    if [[ $start_mins -le $end_mins ]]; then
      if [[ $now_mins -ge $start_mins && $now_mins -lt $end_mins ]]; then
        in_window=1
      fi
    else
      if [[ $now_mins -ge $start_mins || $now_mins -lt $end_mins ]]; then
        in_window=1
      fi
    fi
    if [[ "$in_window" == "0" ]]; then
      exit 0
    fi
  fi
fi

# ---------------------------------------------------------------------------
# Rate limiting / throttle (opt-in)
# ---------------------------------------------------------------------------
throttle_secs="${CODEX_NOTIFY_THROTTLE:-0}"
if [[ "$throttle_secs" -gt 0 ]] 2>/dev/null; then
  throttle_file="$HOME/.codex/.notify-last-ts"
  now_epoch="$(date +%s)"
  if [[ -f "$throttle_file" ]]; then
    last_epoch="$(cat "$throttle_file" 2>/dev/null || echo 0)"
    if [[ $(( now_epoch - last_epoch )) -lt $throttle_secs ]]; then
      exit 0
    fi
  fi
  mkdir -p "$HOME/.codex"
  printf '%s' "$now_epoch" > "$throttle_file"
fi

# ---------------------------------------------------------------------------
# Min-duration / long-run threshold (opt-in)
# ---------------------------------------------------------------------------
format_duration() {
  local secs="$1"
  if [[ "$secs" -lt 60 ]]; then
    echo "${secs}s"
  elif [[ "$secs" -lt 3600 ]]; then
    echo "$(( secs / 60 ))m $(( secs % 60 ))s"
  else
    echo "$(( secs / 3600 ))h $(( (secs % 3600) / 60 ))m $(( secs % 60 ))s"
  fi
}

elapsed_display=""
if [[ "$min_duration" -gt 0 ]] 2>/dev/null && [[ -n "$session_id" ]]; then
  ts_dir="$HOME/.codex/.notify-timestamps"
  mkdir -p "$ts_dir"
  ts_file="$ts_dir/$session_id"
  now_epoch="$(date +%s)"

  if [[ -f "$ts_file" ]]; then
    start_epoch="$(cat "$ts_file" 2>/dev/null || echo "$now_epoch")"
    elapsed=$(( now_epoch - start_epoch ))
    if [[ $elapsed -lt $min_duration ]]; then
      exit 0
    fi
    elapsed_display="$(format_duration "$elapsed")"
    # Reset for next run
    printf '%s' "$now_epoch" > "$ts_file"
  else
    # First notification for this session — record start time, skip notify
    printf '%s' "$now_epoch" > "$ts_file"
    exit 0
  fi

  # Cleanup old timestamp files (>24h)
  find "$ts_dir" -maxdepth 1 -type f -mmin +1440 -delete 2>/dev/null || true
fi

# Append duration to title if available
if [[ -n "$elapsed_display" ]]; then
  title="$title ($elapsed_display)"
fi

# ---------------------------------------------------------------------------
# Terminal echo
# ---------------------------------------------------------------------------
stderr_echo() {
  if [[ "$quiet" != "1" ]]; then
    local line="$title -- $msg"
    if [[ -n "$subtitle" ]]; then
      line="$title -- $msg ($subtitle)"
    fi
    printf '[%s] agent-notify: %s\n' "$(date +%H:%M:%S)" "$line" >&2
  fi
}

stderr_echo

# ---------------------------------------------------------------------------
# Notification log (opt-in)
# ---------------------------------------------------------------------------
if [[ "${CODEX_NOTIFY_LOG:-0}" == "1" ]]; then
  log_file="${CODEX_NOTIFY_LOG_FILE:-$HOME/.codex/notify.log}"
  mkdir -p "$(dirname "$log_file")"
  log_line="$title -- $msg"
  if [[ -n "$subtitle" ]]; then
    log_line="$title -- $msg ($subtitle)"
  fi
  printf '[%s] [%s] [%s] %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "${agent_name:-Manual}" "${sound_category:-completion}" "$log_line" >> "$log_file"
fi

# ---------------------------------------------------------------------------
# Platform-specific: send desktop notification
# ---------------------------------------------------------------------------
send_notification() {
  case "$PLATFORM" in
    macos)
      _send_notification_macos
      ;;
    linux)
      _send_notification_linux
      ;;
    windows)
      _send_notification_windows
      ;;
    *)
      echo "$title: $msg" >&2
      ;;
  esac
}

_send_notification_macos() {
  local tn_bin
  tn_bin="$(command -v terminal-notifier 2>/dev/null || true)"
  if [[ -z "$tn_bin" ]]; then
    for candidate in /opt/homebrew/bin/terminal-notifier /usr/local/bin/terminal-notifier; do
      if [[ -x "$candidate" ]]; then
        tn_bin="$candidate"
        break
      fi
    done
  fi

  if [[ -n "$tn_bin" ]]; then
    local tn_args=(-title "$title" -message "$msg")
    if [[ -n "$subtitle" ]]; then
      tn_args+=(-subtitle "$subtitle")
    fi
    if [[ -n "$group" ]]; then
      tn_args+=(-group "$group")
    fi
    if [[ -n "$app_icon" ]]; then
      tn_args+=(-appIcon "$app_icon")
    fi
    if [[ -n "$activate_bundle" ]]; then
      if [[ "$exec_only" != "0" ]]; then
        if [[ -n "$exec_cmd" ]]; then
          tn_args+=(-execute "$exec_cmd")
        fi
      else
        tn_args+=(-activate "$activate_bundle")
      fi
    fi
    if [[ "$exec_only" == "0" && -n "$sender_bundle" ]]; then
      tn_args+=(-sender "$sender_bundle")
    fi
    local tn_rc=0
    if [[ "${CODEX_NOTIFY_DEBUG:-}" == "1" ]]; then
      "$tn_bin" "${tn_args[@]}" || tn_rc=$?
    else
      "$tn_bin" "${tn_args[@]}" >/dev/null 2>&1 || tn_rc=$?
    fi
    if [[ $tn_rc -ne 0 ]]; then
      _notify_fallback_macos
    fi
  else
    _notify_fallback_macos
  fi
}

_notify_fallback_macos() {
  local fallback_msg="$msg"
  if [[ -n "$subtitle" ]]; then
    fallback_msg="$msg - $subtitle"
  fi
  osascript -e "display notification \"$fallback_msg\" with title \"$title\"" 2>/dev/null \
    || echo "$title: $fallback_msg" >&2
}

_send_notification_linux() {
  local urgency="normal"
  if [[ "$sound_category" == "approval" || "$sound_category" == "error" ]]; then
    urgency="critical"
  fi

  if command -v notify-send >/dev/null 2>&1; then
    local ns_args=(-u "$urgency")
    if [[ -n "$app_icon" ]]; then
      ns_args+=(-i "$app_icon")
    fi
    notify-send "${ns_args[@]}" "$title" "$msg" 2>/dev/null || true
  elif command -v zenity >/dev/null 2>&1; then
    zenity --notification --text="$title: $msg" 2>/dev/null &
    disown
  else
    echo "$title: $msg" >&2
  fi
}

_send_notification_windows() {
  powershell.exe -NoProfile -Command "
    [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
    [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom, ContentType = WindowsRuntime] | Out-Null
    \$xml = [Windows.Data.Xml.Dom.XmlDocument]::new()
    \$xml.LoadXml('<toast><visual><binding template=\"ToastGeneric\"><text>$title</text><text>$msg</text></binding></visual></toast>')
    \$toast = [Windows.UI.Notifications.ToastNotification]::new(\$xml)
    [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier('agent-notify').Show(\$toast)
  " 2>/dev/null || echo "$title: $msg" >&2
}

send_notification

# ---------------------------------------------------------------------------
# Platform-specific: play sound
# ---------------------------------------------------------------------------
play_sound() {
  local s="$1"
  if [[ -z "$s" ]]; then return; fi

  case "$PLATFORM" in
    macos)
      afplay "$s" >/dev/null 2>&1 &
      disown
      ;;
    linux)
      if command -v paplay >/dev/null 2>&1; then
        paplay "$s" >/dev/null 2>&1 &
      elif command -v aplay >/dev/null 2>&1; then
        aplay "$s" >/dev/null 2>&1 &
      elif command -v ffplay >/dev/null 2>&1; then
        ffplay -nodisp -autoexit "$s" >/dev/null 2>&1 &
      fi
      disown 2>/dev/null || true
      ;;
    windows)
      powershell.exe -NoProfile -Command "
        (New-Object Media.SoundPlayer '$s').PlaySync()
      " >/dev/null 2>&1 &
      disown 2>/dev/null || true
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Platform-specific: TTS (text-to-speech)
# ---------------------------------------------------------------------------
speak_tts() {
  local text="$1"
  local voice="${CODEX_NOTIFY_SAY_VOICE:-}"
  local rate="${CODEX_NOTIFY_SAY_RATE:-}"

  case "$PLATFORM" in
    macos)
      local say_args=()
      if [[ -n "$voice" ]]; then say_args+=(-v "$voice"); fi
      if [[ -n "$rate" ]]; then say_args+=(-r "$rate"); fi
      say ${say_args[@]+"${say_args[@]}"} "$text" >/dev/null 2>&1 &
      disown
      ;;
    linux)
      if command -v espeak >/dev/null 2>&1; then
        local es_args=()
        if [[ -n "$voice" ]]; then es_args+=(-v "$voice"); fi
        if [[ -n "$rate" ]]; then es_args+=(-s "$rate"); fi
        espeak ${es_args[@]+"${es_args[@]}"} "$text" >/dev/null 2>&1 &
        disown
      elif command -v spd-say >/dev/null 2>&1; then
        spd-say "$text" >/dev/null 2>&1 &
        disown
      fi
      ;;
    windows)
      powershell.exe -NoProfile -Command "
        Add-Type -AssemblyName System.Speech
        \$synth = New-Object System.Speech.Synthesis.SpeechSynthesizer
        \$synth.Speak('$text')
      " >/dev/null 2>&1 &
      disown 2>/dev/null || true
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Terminal bell
# ---------------------------------------------------------------------------
_should_bell() {
  case "$bell_mode" in
    0|off|false) return 1 ;;
    1|on|true|always) return 0 ;;
    auto|"")
      # Bell when headless: Linux without display, or when no notification tool available
      if [[ "$PLATFORM" == "linux" && -z "${DISPLAY:-}" && -z "${WAYLAND_DISPLAY:-}" ]]; then
        return 0
      fi
      if [[ "$PLATFORM" == "unknown" ]]; then
        return 0
      fi
      return 1
      ;;
    *) return 1 ;;
  esac
}

if _should_bell; then
  printf '\a' >&2
fi

# ---------------------------------------------------------------------------
# TTS
# ---------------------------------------------------------------------------
if [[ "$say_enabled" == "1" && "${CODEX_SILENT:-}" != "1" ]]; then
  speak_tts "$title"
fi

# ---------------------------------------------------------------------------
# Webhook (with preset formatters)
# ---------------------------------------------------------------------------
if [[ -n "$webhook_url" ]]; then
  if command -v python3 >/dev/null 2>&1; then
    webhook_body="$(python3 - "$title" "$msg" "${agent_name:-Manual}" "${sound_category:-completion}" "$webhook_url" "${webhook_preset:-}" "${CODEX_NOTIFY_TELEGRAM_CHAT_ID:-}" "${CODEX_NOTIFY_NTFY_TOPIC:-}" "${session_id:-}" <<'PYWEBHOOK'
import json, sys
from datetime import datetime, timezone

title = sys.argv[1]
message = sys.argv[2]
agent = sys.argv[3]
category = sys.argv[4]
url = sys.argv[5]
preset = sys.argv[6].lower() if sys.argv[6] else ""
telegram_chat_id = sys.argv[7]
ntfy_topic = sys.argv[8]
session_id = sys.argv[9]
ts = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

# Status emoji and color
emoji_map = {
    "completion": "\u2705",  # check
    "approval": "\u26a0\ufe0f",  # warning
    "question": "\u2753",  # question
    "error": "\ud83d\udd34",  # red circle
    "auth": "\ud83d\udd10",  # lock
}
color_map = {
    "completion": "#28a745",
    "approval": "#ffc107",
    "question": "#17a2b8",
    "error": "#dc3545",
    "auth": "#6c757d",
}
discord_color_map = {
    "completion": 0x28a745,
    "approval": 0xffc107,
    "question": 0x17a2b8,
    "error": 0xdc3545,
    "auth": 0x6c757d,
}

emoji = emoji_map.get(category, "\u2139\ufe0f")
color = color_map.get(category, "#6c757d")
discord_color = discord_color_map.get(category, 0x6c757d)

# Auto-detect preset from URL if not set
if not preset:
    if "hooks.slack.com" in url or "slack" in url:
        preset = "slack"
    elif "discord.com/api/webhooks" in url or "discordapp.com" in url:
        preset = "discord"
    elif "api.telegram.org" in url:
        preset = "telegram"
    elif "ntfy.sh" in url or "ntfy" in url:
        preset = "ntfy"

if preset == "slack":
    payload = {
        "attachments": [{
            "color": color,
            "title": f"{emoji} {title}",
            "text": message,
            "footer": f"agent-notify | {agent} | {category}",
            "ts": int(datetime.now(timezone.utc).timestamp()),
            "mrkdwn_in": ["text"],
        }]
    }
elif preset == "discord":
    payload = {
        "username": "Agent Notify",
        "embeds": [{
            "title": f"{emoji} {title}",
            "description": message,
            "color": discord_color,
            "footer": {"text": f"{agent} | {category}"},
            "timestamp": ts,
        }]
    }
elif preset == "telegram":
    text = f"<b>{emoji} {title}</b>\n\n{message}\n\n<i>{agent} | {category}</i>"
    payload = {
        "chat_id": telegram_chat_id,
        "text": text,
        "parse_mode": "HTML",
    }
elif preset == "ntfy":
    # ntfy uses a different payload structure
    priority_map = {"completion": 3, "approval": 4, "question": 4, "error": 5, "auth": 4}
    tag_map = {"completion": "white_check_mark", "approval": "warning", "question": "question", "error": "rotating_light", "auth": "lock"}
    payload = {
        "topic": ntfy_topic or url.rstrip("/").split("/")[-1],
        "title": title,
        "message": message,
        "priority": priority_map.get(category, 3),
        "tags": [tag_map.get(category, "bell")],
    }
else:
    # Generic JSON payload (backwards compatible)
    payload = {
        "content": f"{title} \u2014 {message}",
        "title": title,
        "message": message,
        "agent": agent,
        "category": category,
        "timestamp": ts,
    }

print(json.dumps(payload))
PYWEBHOOK
    )"
  else
    webhook_body="{\"content\":\"$title\"}"
  fi

  # ntfy needs special URL handling (topic in URL, not body)
  if [[ "${webhook_preset:-}" == "ntfy" || "$webhook_url" == *"ntfy"* ]]; then
    # ntfy: POST to topic URL with JSON body
    curl -s -X POST -H "Content-Type: application/json" \
      -d "$webhook_body" "$webhook_url" >/dev/null 2>&1 &
  else
    curl -s -X POST -H "Content-Type: application/json" \
      -d "$webhook_body" "$webhook_url" >/dev/null 2>&1 &
  fi
  disown
fi

# ---------------------------------------------------------------------------
# Custom hook (opt-in)
# ---------------------------------------------------------------------------
notify_hook="${CODEX_NOTIFY_HOOK:-}"
if [[ -n "$notify_hook" ]]; then
  if [[ "${CODEX_NOTIFY_DEBUG:-}" == "1" ]]; then
    $notify_hook "$title" "$msg" "${sound_category:-completion}" "${agent_name:-Manual}" &
  else
    $notify_hook "$title" "$msg" "${sound_category:-completion}" "${agent_name:-Manual}" >/dev/null 2>&1 &
  fi
  disown
fi

# ---------------------------------------------------------------------------
# Play sound
# ---------------------------------------------------------------------------
play_sound "$sound"

# ---------------------------------------------------------------------------
# Activate editor (Linux/Windows — click-to-focus handled by terminal-notifier on macOS)
# ---------------------------------------------------------------------------
if [[ "$PLATFORM" != "macos" && -n "$activate_cmd" ]]; then
  eval "$activate_cmd" >/dev/null 2>&1 &
  disown 2>/dev/null || true
fi
